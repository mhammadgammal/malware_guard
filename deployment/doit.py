import tensorflow as tf
from tensorflow.keras.preprocessing.image import load_img, img_to_array

import numpy as np

# Define the malware classes and their finer-grained classes
malware_classes = ["Backdoor", "Dialer", "PWS", "Rogue", "TDownloader", "Trojan", "Worms"]
class_hierarchy = {
    "Backdoor": ["Agent.FYI", "Rbot!gen"],
    "Dialer": ["Adialer.C", "Dialplatform.B", "Instantaccess"],
    "PWS": ["Lolyda.AA1", "Lolyda.AA2", "Lolyda.AA3", "Lolyda.AT"],
    "Worms": ["Allaple.A", "Allaple.L", "Autorun.K", "VB.AT", "Yuner.A"],
    "Trojan": ["Alueron.gen!J", "C2LOP.gen!g", "C2LOP.P", "Malex.gen!J", "Skintrim.N"],
    "TDownloader": ["Dontovo.A", "Obfuscator.AD", "Swizzor.gen!E", "Swizzor.gen!I", "Wintrim.BX"],
    "Rogue": ['Fakerean']
}

# Function to load CNN model based on predicted class index
def load_cnn_model(predicted_class):
    model_paths = {
        0: './MalwareProject/cnn_Backdoor.h5',
        1: './MalwareProject/cnn_Dialer.h5',
        2: './MalwareProject/cnn_PWS.h5',
        3: './MalwareProject/cnn_Rogue.h5',
        4: './MalwareProject/cnn_TDownloader.h5',
        5: './MalwareProject/cnn_Trojan.h5',
        6: './MalwareProject/cnn_Worms.h5'
    }
    
    if predicted_class in model_paths:
        model_path = model_paths[predicted_class]
        return tf.keras.models.load_model(model_path)
    else:
        raise ValueError(f"No model found for class index {predicted_class}")

# Specify ResNet-50 model path
'deployment\MalwareProject\ResNet50_model.h5'
resnet50_model_path = './MalwareProject/Another_CNN.h5'

# Function to preprocess and predict using ResNet-50 model
def test_single_image_with_resnet50(image_path, model_path, confidence_threshold=0.75):
    # Preprocess the image
    img = load_img(image_path, target_size=(224, 224))
    img_array = img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = img_array / 255.0  # Normalize the image
    
    # Load ResNet-50 model
    model = tf.keras.models.load_model(model_path)
    
    # Predict using ResNet-50 model
    prediction = model.predict(img_array)
    predicted_class = np.argmax(prediction, axis=1)
    confidence = np.max(prediction)
    
    # Check confidence threshold
    if confidence < confidence_threshold:
        print(f"ResNet-50: Predicted class is Unknown with confidence {confidence:.2f}")
        return None, confidence
    else:
        predicted_class_name = malware_classes[predicted_class[0]]
        print(f"ResNet-50: Predicted class is {predicted_class_name} with confidence {confidence:.2f}")
        return predicted_class[0], confidence

# Function to predict subclass using CNN model
def predict_subclass(image_path, cnn_model, predicted_class):
    # Preprocess the image
    img = load_img(image_path, target_size=(224, 224))
    img_array = img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = img_array / 255.0  # Normalize the image
    
    # Predict using CNN model
    prediction = cnn_model.predict(img_array)
    predicted_subclass_index = np.argmax(prediction, axis=1)
    predicted_subclass_name = class_hierarchy[malware_classes[predicted_class]][predicted_subclass_index[0]]
    
    print(f"CNN Model: Predicted subclass is {predicted_subclass_name}")
    return predicted_subclass_name

# Specify the image path
image_path = './uploads/trojan_test_alueron_genj.png'

# Test the single images with ResNet-50 model and load CNN models
print("*********************************************")
predicted_class, confidence = test_single_image_with_resnet50(image_path, resnet50_model_path)
if predicted_class is not None:
    cnn_model = load_cnn_model(predicted_class)
    if cnn_model:
        predicted_subclass = predict_subclass(image_path, cnn_model, predicted_class)
        print(f"Loaded CNN model for predicted class index {predicted_class} and subclass {predicted_subclass}")
    else:
        print("Failed to load CNN model.")
else:
    print("ResNet-50 predicted class is Unknown, cannot load CNN model.")
print("*********************************************")
