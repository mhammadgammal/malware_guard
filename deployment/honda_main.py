import os
import cv2
import joblib
import numpy as np
from skimage.feature import hog
from skimage import exposure
from collections import Counter
from fastapi import FastAPI, Request, Form, File, UploadFile
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel

app = FastAPI()
static_dir = os.path.join(os.path.dirname(__file__), "static")
app.mount("/static", StaticFiles(directory=static_dir), name="static")
templates = Jinja2Templates(directory="T")


# Function to preprocess image
def preprocess_image(image_path):
    img = cv2.imread(image_path)
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    img_resized = cv2.resize(img_gray, (128, 64))
    features = hog(img_resized, orientations=8, pixels_per_cell=(8, 8),
                   cells_per_block=(1, 1), visualize=False)
    features = exposure.rescale_intensity(features, in_range=(0, 10))
    return features


# Function to predict image class
def predict_image_class(image_path, models):
    preprocessed_image_features = preprocess_image(image_path)
    predicted_classes = []

    for model_name, model in models.items():
        predicted_class = model.predict([preprocessed_image_features])
        predicted_classes.append(predicted_class[0])

    class_counts = Counter(predicted_classes)
    most_frequent_class = class_counts.most_common(1)[0][0]

    malware_classes = ["Backdoor", "Dialer", "PWS", "Rogue", "TDownloader", "Trojan", "Worms"]
    return malware_classes[most_frequent_class]


def predict_image_class_Dialer(image_path, models):
    preprocessed_image_features = preprocess_image(image_path)
    predicted_classes = []

    # Predict using each model and store the predictions
    for model_name, model in models.items():
        predicted_class = model.predict([preprocessed_image_features])
        predicted_classes.append(predicted_class[0])  # Append the predicted class

    # Count occurrences of each predicted class
    class_counts = Counter(predicted_classes)

    most_frequent_class = class_counts.most_common(1)[0][0]

    l = ["Adialer.C", "Dialplatform.B", "Instantaccess"]

    return l[most_frequent_class]


def predict_image_class_PWS(image_path, models):
    preprocessed_image_features = preprocess_image(image_path)
    predicted_classes = []

    # Predict using each model and store the predictions
    for model_name, model in models.items():
        predicted_class = model.predict([preprocessed_image_features])
        predicted_classes.append(predicted_class[0])  # Append the predicted class

    # Count occurrences of each predicted class
    class_counts = Counter(predicted_classes)

    most_frequent_class = class_counts.most_common(1)[0][0]

    l = ["Lolyda.AA1", "Lolyda.AA2", "Lolyda.AA3", "Lolyda.AT"]

    return l[most_frequent_class]


def predict_image_class_Backdoor(image_path, models):
    preprocessed_image_features = preprocess_image(image_path)
    predicted_classes = []

    # Predict using each model and store the predictions
    for model_name, model in models.items():
        predicted_class = model.predict([preprocessed_image_features])
        predicted_classes.append(predicted_class[0])  # Append the predicted class

    # Count occurrences of each predicted class
    class_counts = Counter(predicted_classes)

    most_frequent_class = class_counts.most_common(1)[0][0]

    l = ["Agent.FYI", "Rbot!gen"]

    return l[most_frequent_class]


def predict_image_class_Worms(image_path, models):
    preprocessed_image_features = preprocess_image(image_path)
    predicted_classes = []

    # Predict using each model and store the predictions
    for model_name, model in models.items():
        predicted_class = model.predict([preprocessed_image_features])
        predicted_classes.append(predicted_class[0])  # Append the predicted class

    # Count occurrences of each predicted class
    class_counts = Counter(predicted_classes)

    most_frequent_class = class_counts.most_common(1)[0][0]

    l = ["Allaple.A", "Allaple.L", "Autorun.K", "VB.AT", "Yuner.A"]

    return l[most_frequent_class]


def predict_image_class_Trojan(image_path, models):
    preprocessed_image_features = preprocess_image(image_path)
    predicted_classes = []

    # Predict using each model and store the predictions
    for model_name, model in models.items():
        predicted_class = model.predict([preprocessed_image_features])
        predicted_classes.append(predicted_class[0])  # Append the predicted class

    # Count occurrences of each predicted class
    class_counts = Counter(predicted_classes)

    most_frequent_class = class_counts.most_common(1)[0][0]

    l = ["Alueron.gen!J", "C2LOP.gen!g", "C2LOP.P", "Malex.gen!J", "Skintrim.N"]

    return l[most_frequent_class]


def predict_image_class_TDownloader(image_path, models):
    preprocessed_image_features = preprocess_image(image_path)
    predicted_classes = []

    # Predict using each model and store the predictions
    for model_name, model in models.items():
        predicted_class = model.predict([preprocessed_image_features])
        predicted_classes.append(predicted_class[0])  # Append the predicted class

    # Count occurrences of each predicted class
    class_counts = Counter(predicted_classes)

    most_frequent_class = class_counts.most_common(1)[0][0]

    l = ["Dontovo.A", "Obfuscator.AD", "Swizzor.gen!E", "Swizzor.gen!I", "Wintrim.BX"]

    return l[most_frequent_class]


# Load models
def load_models(model_dir):
    models = {}
    for model_file in os.listdir(model_dir):
        if model_file.endswith('.pkl') and not model_file == 'decision_tree_model.pkl':
            model_name = os.path.splitext(model_file)[0]
            print(model_name)
            models[model_name] = joblib.load(os.path.join(model_dir, model_file))
    return models


model_dir = 'saved_models'
loaded_models = load_models(model_dir)


# HTML form input model
class ImageForm(BaseModel):
    file: UploadFile


# FastAPI endpoint to handle image upload and prediction
@app.post("/predict/")
async def predict(request: Request, file: UploadFile = Form(...)):
    # Save uploaded image locally
    image_path = os.path.join("static", file.filename)
    with open(image_path, "wb") as f:
        f.write(await file.read())

    # Predict image class
    predicted_class = predict_image_class(image_path, loaded_models)

    # Determine the family of the predicted class
    if predicted_class == "Rogue":
        prediction_text = "family is Fakerean"
    elif predicted_class == "Worms":
        worms_dir = 'saved_models_Worms'
        loaded_models_worms = load_models(worms_dir)
        prediction_text = f"Predicted Family is: {predict_image_class_Worms(image_path, loaded_models_worms)}"
    elif predicted_class == "Trojan":
        Trojan_dir = 'saved_models_Trojan'
        loaded_models_Trojan = load_models(Trojan_dir)
        prediction_text = f"Predicted Family is: {predict_image_class_Trojan(image_path, loaded_models_Trojan)}"
    elif predicted_class == "Backdoor":
        Backdoor_dir = 'saved_models_Backdoor'
        loaded_models_Backdoor = load_models(Backdoor_dir)
        prediction_text = f"Predicted Family is: {predict_image_class_Backdoor(image_path, loaded_models_Backdoor)}"
    elif predicted_class == "PWS":
        PWS_dir = 'saved_models_PWS'
        loaded_models_PWS = load_models(PWS_dir)
        prediction_text = f"Predicted Family is: {predict_image_class_PWS(image_path, loaded_models_PWS)}"
    elif predicted_class == "TDownloader":
        TDownloader_dir = 'saved_models_TDownloader'
        loaded_models_TDownloader = load_models(TDownloader_dir)
        prediction_text = f"Predicted Family is: {predict_image_class_TDownloader(image_path, loaded_models_TDownloader)}"
    elif predicted_class == "Dialer":
        Dialer_dir = 'saved_models_Dialer'
        loaded_models_Dialer = load_models(Dialer_dir)
        prediction_text = f"Predicted Family is: {predict_image_class_Dialer(image_path, loaded_models_Dialer)}"
    else:
        prediction_text = "No family prediction available"

    # Render HTML response
    print(prediction_text)
    return templates.TemplateResponse("result.html", {"request": request, "image_filename": file.filename,
                                                      "predicted_class": predicted_class,
                                                      "prediction_text": prediction_text})


# FastAPI endpoint to render the upload form
@app.get("/")
async def main(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})


# Conditional block to run the FastAPI server with uvicorn
if __name__ == "_main_":
    import uvicorn

    uvicorn.run(app, host="127.0.0.1", port=8000)