import io
import numpy as np
from fastapi import FastAPI, UploadFile, File, HTTPException, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from PIL import Image
import os
import joblib

app = FastAPI()

# Define directory paths
static_dir = os.path.join(os.path.dirname(__file__), "static")
templates_dir = os.path.join(os.path.dirname(__file__), "templates")
model_path = os.path.join(os.path.dirname(__file__), "svm_model.pkl")

# Mount static directory for serving static files
app.mount("/static", StaticFiles(directory=static_dir), name="static")

# Use Jinja2Templates for loading HTML templates
templates = Jinja2Templates(directory=templates_dir)

# Load the machine learning model
model = joblib.load(model_path)

@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/upload/")
async def upload_file(exe_file: UploadFile = File(...)):
    try:
        # Create uploads directory if it doesn't exist
        uploads_dir = os.path.join(os.path.dirname(__file__), "uploads")
        os.makedirs(uploads_dir, exist_ok=True)

        # Save uploaded file to uploads directory
        filename = os.path.join(uploads_dir, exe_file.filename)
        with open(filename, "wb") as f:
            f.write(exe_file.file.read())

        # Perform conversion
        output_filename = convert_to_image(filename)

        # Prepare response data
        return {"image_path": output_filename}

    except (FileNotFoundError, PermissionError) as e:
        raise HTTPException(status_code=500, detail=f"Error uploading file: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/show/", response_class=HTMLResponse)
async def show_image(request: Request, image_path: str = None):
    if not image_path:
        raise HTTPException(status_code=400, detail="Image path is missing.")
    return templates.TemplateResponse("show.html", {"request": request, "image_path": image_path})

@app.post("/predict/")
async def predict(image: UploadFile = File(...)):
    try:
        # Save uploaded image to a temporary file
        with open("temp_image.jpg", "wb") as f:
            f.write(image.file.read())

        # Open the image using PIL
        img = Image.open("temp_image.jpg")

        # Perform any preprocessing if necessary

        # Convert the image to a numpy array
        img_array = np.array(img)

        # Perform prediction using the model
        prediction = model.predict([img_array])

        # Return the prediction result
        return {"prediction": prediction}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

def convert_to_image(input_file):
    try:
        output_filename = os.path.splitext(os.path.basename(input_file))[0] + "_output.png"
        output_filepath = os.path.join(static_dir, output_filename)

        with open(input_file, 'rb') as file:
            binary_data = file.read()

        data_size = len(binary_data)
        image_width = int(data_size ** 0.5) + 1
        image_height = (data_size // image_width) + 1

        image = Image.new('RGB', (image_width, image_height))
        pixels = image.load()

        index = 0
        for y in range(image_height):
            for x in range(image_width):
                if index < data_size:
                    byte_value = binary_data[index]
                    pixels[x, y] = (byte_value, byte_value, byte_value)
                    index += 1

        image.save(output_filepath)
        return output_filename

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error converting file: {e}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)
