import io
from fastapi import FastAPI, UploadFile, File, HTTPException, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from PIL import Image
import os
import joblib
import numpy as np

import tensorflow as tf
# from tensorflow.keras.models import load_model
# from tensorflow.keras.preprocessing import image
import keras
from keras._tf_keras.keras.models import load_model
app = FastAPI()

# Define directory paths
static_dir = os.path.join(os.path.dirname(__file__), "static")
templates_dir = os.path.join(os.path.dirname(__file__), "templates")
model_path = os.path.join(os.path.dirname(__file__), "svm_model.pkl")
vgg_model_path = os.path.join(os.path.dirname(__file__), "MalwareProject\VGG16_model.h5")
# "C:\Users\m7ame\StudioProjects\malware_guard\deployment\MalwareProject\decision_tree_model.pkl"
des_tree_model_path = os.path.join(os.path.dirname(__file__), "./MalwareProject/logistic_regression_model.pkl")
# Mount static directory for serving static files
app.mount("/static", StaticFiles(directory=static_dir), name="static")
app.add_middleware(
    CORSMiddleware,
    allow_origins=['*'],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Use Jinja2Templates for loading HTML templates
templates = Jinja2Templates(directory=templates_dir)
# Load the machine learning model
model = joblib.load(model_path)
des_tree_model = joblib.load(des_tree_model_path)

# vgg_model = load_model(vgg_model_path)

@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/upload/")
async def upload_file(exe_file: UploadFile = File(...)):
    try:
        print(exe_file)
        # Create uploads directory if it doesn't exist
        uploads_dir = os.path.join(os.path.dirname(__file__), "uploads")
        print(uploads_dir)
        os.makedirs(uploads_dir, exist_ok=True)

        # Save uploaded file to uploads directory
        filename = os.path.join(uploads_dir, exe_file.filename)
        with open(filename, "wb") as f:
            f.write(exe_file.file.read())

        # Perform conversion
        output_filepath = convert_to_image(filename)
        # Prepare response data
        image_filename = os.path.basename(output_filepath)
        image_path = f"{image_filename}"
        print(image_path)
        return {"image_path": image_path}
    
    except (FileNotFoundError, PermissionError) as e:
        return {"error": str(e)}
    except Exception as e:
         return {"error": str(e)}

@app.get("/get_image/{image_name}")
async def get_image(image_name: str):
    # Assuming the image name is passed as a parameter in the URL
    # You can construct the path to the image file based on the image name
    image_path = f"uploads/{image_name}"
    return FileResponse(image_path)

# def pred(image_content: bytes):
#     try:
#         print('in prediction')
#         # Open the image using PIL
#         img = Image.open(io.BytesIO(image_content))
#         print('image opened')
#         # Perform any preprocessing if necessary

#         # Convert the image to a numpy array
#         img_array = np.array(img)
#         print('before prediction')
#         # Perform prediction using the model
#         prediction = model.predict([img_array])
#         print(f'{prediction}')

#         # Return the prediction result
#         return prediction.tolist()  # Convert prediction to list for JSON serializable

#     except Exception as e:
#         print(f'Error: {e}')
#         raise HTTPException(status_code=500, detail=str(e))
    
# @app.post("/predict/")
def predict(image: str):
    print('in predict')
    try:
        # Save uploaded image to a temporary file
        
        print(f'uploads/{image}')

        # Open the image using PIL
        img = Image.open(f'uploads/{image}', 'r')
        print('image opened')
        # Perform any preprocessing if necessary

        # Convert the image to a numpy array
        img_array = np.array(img)
        img_array = img_array.reshape(-1, img_array.shape[0] * img_array.shape[1])
        
        print('before prediction')
        # Perform prediction using the model
        prediction = des_tree_model.predict(img_array)
        print(f'{prediction}')

        # Return the prediction result
        return {"prediction": prediction}

    except Exception as e:
        print(f'Error: {e}')
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/show/", response_class=HTMLResponse)
async def show_image(request: Request, image_path: str):
    return templates.TemplateResponse("show.html", {"request": request, "image_path": image_path})


def convert_to_image(input_file):
    try:
        output_filepath = os.path.splitext(input_file)[0] + "_output.png"

        with open(input_file, 'rb') as file:
            binary_data = file.read()

        data_size = len(binary_data)
        image_width = int(data_size ** 0.5) + 1
        image_height = (data_size // image_width) + 1

        image = Image.new('RGB', (image_width, image_height))
        pixels = image.load()

        index = 0
        for y in range(image_height):
            for x in range(image_width):
                if index < data_size:
                    byte_value = binary_data[index]
                    pixels[x, y] = (byte_value, byte_value, byte_value)
                    index += 1

        image.save(output_filepath)
        return output_filepath

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error converting file: {e}")


def open_image(encoded_data):
    image = Image.open(io.BytesIO(encoded_data))
    image.show()


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)

