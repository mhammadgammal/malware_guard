import io
from fastapi import FastAPI, UploadFile, File, HTTPException, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from PIL import Image
import os
import joblib
import numpy as np
import tensorflow as tf
# from tensorflow.keras.models import load_model
# from tensorflow.keras.preprocessing import image
import keras
from keras._tf_keras.keras.models import load_model
import numpy as np
app = FastAPI()

# Define directory paths
static_dir = os.path.join(os.path.dirname(__file__), "static")
templates_dir = os.path.join(os.path.dirname(__file__), "templates")
model_path = os.path.join(os.path.dirname(__file__), "svm_model.pkl")
vgg_model_path = os.path.join(os.path.dirname(__file__), "MalwareProject\VGG16_model.h5")
# Mount static directory for serving static files
app.mount("/static", StaticFiles(directory=static_dir), name="static")
app.add_middleware(
    CORSMiddleware,
    allow_origins=['*'],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# Use Jinja2Templates for loading HTML templates
templates = Jinja2Templates(directory=templates_dir)
# Load the machine learning model
model = joblib.load(model_path)
vgg_model = load_model(vgg_model_path)
@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/upload/")
async def upload_file(exe_file: UploadFile = File(...)):
    try:
        print(exe_file)
        # Create uploads directory if it doesn't exist
        uploads_dir = os.path.join(os.path.dirname(__file__), "uploads")
        print(uploads_dir)
        os.makedirs(uploads_dir, exist_ok=True)

        # Save uploaded file to uploads directory
        filename = os.path.join(uploads_dir, exe_file.filename)
        with open(filename, "wb") as f:
            f.write(exe_file.file.read())

        # Perform conversion
        output_filepath = convert_to_image(filename)


        # Prepare response data
        image_filename = os.path.basename(output_filepath)
        print(f'image filename: {image_filename}')
        image_path = f"{image_filename}"
        # Read the image file into bytes
        with open(os.path.join('./uploads', image_path), 'rb') as f:
            image_content = f.read()
        # Call the prediction function
        
        print(f'image path after predic method: {image_path}')
        return {"image_path": image_path}
    
    except (FileNotFoundError, PermissionError) as e:
        return {"error": str(e)}
    except Exception as e:
         return {"error": str(e)}

@app.get("/get_image/{image_name}")
async def get_image(image_name: str):
    # Assuming the image name is passed as a parameter in the URL
    # You can construct the path to the image file based on the image name
    print(image_name)
    image_path = f"uploads/{image_name}"
    return FileResponse(image_path)


def pred(image_content: bytes):
    try:
        print('in predict')
        # Open the image using PIL
        img = Image.open(io.BytesIO(image_content))
        print('in reading image')
        # Perform any preprocessing if necessary

        print('before prediction')
        # Convert the image to a numpy array
        img_array = np.array(img)

        # Perform prediction using the model
        prediction = model.predict([img_array])
        print(f'prediction: {prediction}')
        # Return the prediction result
        return prediction.tolist()  # Convert prediction to list for JSON serializable

    except Exception as e:
        print(f'error: {e}')
        raise HTTPException(status_code=500, detail=str(e))

# @app.post("/predict/")
def predict(image: UploadFile = File(...)):
    print('in predict')
    try:

        with open(image.filename, "wb") as f:
            f.write(image.file.read())
            print('in reading image')
        # Read the file contents
        file_contents = image.file.read()

        # Convert to a PIL image
        img = Image.open(io.BytesIO(file_contents))

        # Perform any preprocessing if necessary

        # Convert the image to a numpy array
        img_array = np.array(img)
        print('before prediction')
        # Perform prediction using the model
        prediction = vgg_model.predict([img_array])
        print(f'prediction: {prediction}')
        # Return the prediction result
        return {"prediction": prediction}

    except Exception as e:
        print(f'error: {e}')
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/show/", response_class=HTMLResponse)
async def show_image(request: Request, image_path: str):
    return templates.TemplateResponse("show.html", {"request": request, "image_path": image_path})


def convert_to_image(input_file):
    try:
        output_filepath = os.path.splitext(input_file)[0] + "_output.png"

        with open(input_file, 'rb') as file:
            binary_data = file.read()

        data_size = len(binary_data)
        image_width = int(data_size ** 0.5) + 1
        image_height = (data_size // image_width) + 1

        image = Image.new('RGB', (image_width, image_height))
        pixels = image.load()

        index = 0
        for y in range(image_height):
            for x in range(image_width):
                if index < data_size:
                    byte_value = binary_data[index]
                    pixels[x, y] = (byte_value, byte_value, byte_value)
                    index += 1

        image.save(output_filepath)
        return output_filepath

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error converting file: {e}")


def open_image(encoded_data):
    image = Image.open(io.BytesIO(encoded_data))
    image.show()


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="127.0.0.1", port=8000)
