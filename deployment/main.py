import io
from fastapi import FastAPI, UploadFile, File, HTTPException, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from PIL import Image
import os
import joblib
import numpy as np
app = FastAPI()

# Define directory paths
static_dir = os.path.join(os.path.dirname(__file__), "static")
templates_dir = os.path.join(os.path.dirname(__file__), "templates")
model_path = os.path.join(os.path.dirname(__file__), "svm_model.pkl")
# Mount static directory for serving static files
app.mount("/static", StaticFiles(directory=static_dir), name="static")
app.add_middleware(
    CORSMiddleware,
    allow_origins=['*'],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# Use Jinja2Templates for loading HTML templates
templates = Jinja2Templates(directory=templates_dir)
# Load the machine learning model
model = joblib.load(model_path)


@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/upload/")
async def upload_file(exe_file: UploadFile = File(...)):
    try:
        print(exe_file)
        # Create uploads directory if it doesn't exist
        uploads_dir = os.path.join(os.path.dirname(__file__), "uploads")
        print(uploads_dir)
        os.makedirs(uploads_dir, exist_ok=True)

        # Save uploaded file to uploads directory
        filename = os.path.join(uploads_dir, exe_file.filename)
        with open(filename, "wb") as f:
            f.write(exe_file.file.read())

        # Perform conversion
        output_filepath = convert_to_image(filename)

        # Prepare response data
        image_filename = os.path.basename(output_filepath)
        image_path = f"{image_filename}"
        print(image_path)
        return {"image_path": image_path}
    
    except (FileNotFoundError, PermissionError) as e:
        return {"error": str(e)}
    except Exception as e:
         return {"error": str(e)}

@app.get("/get_image/{image_name}")
async def get_image(image_name: str):
    # Assuming the image name is passed as a parameter in the URL
    # You can construct the path to the image file based on the image name
    image_path = f"uploads/{image_name}"
    return FileResponse(image_path)


@app.post("/predict/")
async def predict(image: UploadFile = File(...)):
    try:
        # Save uploaded image to a temporary file
        with open("temp_image.jpg", "wb") as f:
            f.write(image.file.read())

        # Open the image using PIL
        img = Image.open("temp_image.jpg")

        # Perform any preprocessing if necessary

        # Convert the image to a numpy array
        img_array = np.array(img)

        # Perform prediction using the model
        prediction = model.predict([img_array])

        # Return the prediction result
        return {"prediction": prediction}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/show/", response_class=HTMLResponse)
async def show_image(request: Request, image_path: str):
    return templates.TemplateResponse("show.html", {"request": request, "image_path": image_path})


def convert_to_image(input_file):
    try:
        output_filepath = os.path.splitext(input_file)[0] + "_output.png"

        with open(input_file, 'rb') as file:
            binary_data = file.read()

        data_size = len(binary_data)
        image_width = int(data_size ** 0.5) + 1
        image_height = (data_size // image_width) + 1

        image = Image.new('RGB', (image_width, image_height))
        pixels = image.load()

        index = 0
        for y in range(image_height):
            for x in range(image_width):
                if index < data_size:
                    byte_value = binary_data[index]
                    pixels[x, y] = (byte_value, byte_value, byte_value)
                    index += 1

        image.save(output_filepath)
        return output_filepath

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error converting file: {e}")


def open_image(encoded_data):
    image = Image.open(io.BytesIO(encoded_data))
    image.show()


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="127.0.0.1", port=8000)
